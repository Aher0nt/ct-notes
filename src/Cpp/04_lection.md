<!-- TODO мотивация -->
# Процесс компиляции C++ программы

Программы на C++ компилируются с помощью компилятора. Один из популярных компиляторов - g++:

```g++ hello.cpp```

Сам g++ по себе ничего не делает, он запускает другие программы. На linux, если использовать ```strace -f -e trace = execve```

То он запускает.

Пройдем код:

```cpp
hello world insert
```
## Разберем процесс компиляции поэтапно

### Препроцессинг

Препроцессор - это первый этап компиляции. Он обрабатывает директивы препроцессора, такие как ```#include```, ```#define```, ```#ifdef``` и т.д.
Чтобы увидеть результат работы препроцессора, можно использовать следующую команду:

```g++ -E -P hello.cpp > hello.i```

Эта команда создаст файл hello.i, который будет содержать код после обработки препроцессором. В этом файле вы увидите:
- Раскрытые макросы
- Вставленный код из заголовочных файлов
- Удаленные комментарии
- Обработанные условные директивы (```#ifdef```, ```#ifndef``` и т.д.)

Пример:
<!-- TODO пример -->

### Трансляция

Она делает комманду:

```g++ -s -masm=intel -02 hello.i```

Она переводит C++ программу в язык ассемблера

### Ассемблирование

Берем ассемблерный код переводим в машинный код:

```as -o hello.o hello.s```

Результат хранится в объектном файле

Есть утилита ```objump```

```objdemp -drC -Mintel hello.o```

### Линковка

```g++ -o hello.o ``` скипнд


#### В чем отличие объектного и исполняемого файла



Теперь давайте посмотрим, когда программа состоит из нескольких файлов.

независимо

В самом конце все файлы объединяются в один.

## Программа в нескольких файлах

тут надо расписать, про то что линковщик не увидит файлы


```cpp
void foo(int_32 t);
```
```cpp
void foo(int_32 t){
    ...
}
```

По поводу объявлений.

Мы не можем вызвать функцию, которая находится снизу

<!-- TODO 2 примера кода -->
<!-- TODO multiple definition -->
<!-- TODO static declaration -->

### static

Он вообще по-разному юзается, он ферзь

У глобальных переменных инициализация нулем.
