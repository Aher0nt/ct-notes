# Примеры кода на ассемблере

На этой практике мы потрогаем ассемблер

### Hello World

Справа вы можете видеть код:

'''nasm
section .text
global _start

_start:
    mov rax, 1
    mov rdi, 1
    mov rsi, msg
    mov rdx, msg_size
    syscall

    mov rax, 60
    xor rdi, rdi
    syscall

section .rodata
msg: db "Hello, world!", 0x0a
msg_size: equ $ - msgbash
'''

Давайте сперва покажем, как компилировать программу на ассемблере:

'''
nasm -felf64 hello.asm
'''

nasm - сам компилятор, -felf64 - формат кодирования для 64-битного линукса и название файла.

Теперь, если вы заметите, то у вас появился файл hello.o - объектный файл.

Чтобы создать файлик, который мы можем запускать, мы должны написать:

'''
ld hello.o
'''

ld - ссылочный компилятор, hello.o - объектный файл, который мы создали ранее. Пока вы не знаете, что это такое, но позже по курсу узнаете. Так вот, эта команда создаст файл a.out, который уже можно будет запустить и он выведет наш "Hello, World".

Теперь давайте говорить про код:

1.  В этом коде мы видим section:

    Исполняемые файлы в нынешнее время большинство имеют отдельное место под код (условно говоря .text), отдельное место для неизменяемой памяти (.rodata) и другие.

2.  Когда наша программа компилируется, она будет запускаться из функции _start.

3.  global _start нужен для того, чтобы линковщик мог к ней обратиться (иначе файл бы не запустился, т.к. не видел бы начало программы).

4.  Мы распихиваем с помощью mov в какие-то регистры какие-то числа, а потом делаем syscall. Что делает syscall? Просит ядро операционной системы вызвать какую-то команду в зависимости от значения на регистре rax. Какую вы можете посмотреть сюда: Linux_System_Call_Table (https://en.wikipedia.org/wiki/System_call#Linux_kernel)

    Когда мы хотим сделать какой-то системный вызов, мы читаем rax и в зависимости от него делаем команду.

5.  Рассмотрим эту часть кода:

    ''' asm
    mov rax, 1
    mov rdi, 1
    mov rsi, msg
    mov rdx, msg_size
    syscall
    '''

    Что у нас происходит? Мы кладем в rax - 1, откуда это команда write, потом в rdi кладем 1, в rsi кладем указатель на сообщение, а в rdx передаем msg_size, как от нас и требуется по Linux_System_Call_Table  и вызываем syscall.

    И мы побеждаем!